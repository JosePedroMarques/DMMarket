\documentclass{llncs}

\usepackage[english]{babel}
\usepackage[T1]{fontenc}  
\usepackage[utf8]{inputenc}
\usepackage[usenames,dvipsnames,table]{xcolor}
\bibliographystyle{splncs}
\usepackage{url}


\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{chngpage}
\usepackage{fancyhdr}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{algorithmicx}

\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}

\lhead{\color{gray}\footnotesize MPES - Post Enrolment Scheduling}
\rhead{\color{gray}\footnotesize Jos√© Pedro Marques}
\lfoot{\color{gray}\footnotesize \rightmark}
\rfoot{\color{gray} \footnotesize Page. \thepage} 
\cfoot{}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}


\begin{document}

\title{POST ENROLMENT SCHEDULING}
\subtitle{Methodologies for Planning and Scheduling}
\author{Jos\'e Pedro Marques}
\institute{Faculdade de Engenharia da Universidade do Porto}
\date{May 10, 2012}
\maketitle

\begin{abstract}

This paper shows the comparison of the results obtained when solving the Post Enrolment Scheduling problem using two different approaches: An iterative solution improved by Simulated Annealing, and an evolutionary algorithm implementation. The problem model, and its datasets were taken from the 2007 International Timetabling Competition. 
\end{abstract}

\section{Introduction}

The purpose of this article is to present and compare the results obtained when solving a Post Enrolment Scheduling Problem with two different approaches: Simulated Annealing and Evolutionary Algorithms, both of them implemented in Java. The main goal is to compare a Local Search algorithm with a meta-heuristic, and try to understand for each approach its strengths and weaknesses. 

This article will include a description of the problem itself (Section 2) and a detailed description on how the algorithms were implemented (Section 3) and then present the results obtained with both approaches (Section 4). Finally, it includes a small conclusion with some remarks and comments on the results obtained, and possible future implementations (Section 5).


\section{Post Enrolment Scheduling}

This section will explain the details of the Post Enrolment Scheduling problem, it's hard and soft constraints and how to evaluate each solution. These were all taken from the 2007 International Timetabling Competition \cite{itc:2007}

\subsection{Description}

This timetabling problem is intended to simulate the real-world situation where
students are given a choice of lectures that they wish to attend, and the timetable is then
constructed according to these choices (i.e., the timetable is to be constructed after students
have selected the lectures they wish to attend).


\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{Timetable.png}
\caption{Timetable example}
\label{fig:ttb}
\end{figure}

The problem consists of the following:
\begin{itemize}
\item A set of events that are to be scheduled into 45 time slots (5 days of 9 hours each).
\item A set of rooms, each of which has a specific seating capacity, in which the events take
place.
\item A set of room features that are satisfied by rooms and which are required by events (i.e. an event
needs rooms with computers and an overhead projector)
\item A set of students who attend various different combinations of events.
\item A set of available time slots for each of the events (i.e. not all events can be placed in all
time slots)
\end{itemize}



The aim is to try and insert each of the given events into the timetable - figure \ref{fig:ttb}-  (that is, assign each event to one of the rooms and one of the 45 time slots) while obeying the following
hard constraints:


\begin{itemize}
\item No student should be required to attend more than one event at the same time.
\item In each case, the room should be big enough for all of the attending students and should
satisfy all of the features required by the event.
\item Only one event is put into each room in any time slot.
\item Events should only be assigned to time slots that are pre-defined as available for those
events.
\item Where specified, events should be scheduled to occur in the correct order during the week.
\end{itemize}

In addition to the five hard constraints that are given above, the following soft constraints
are included in the problem:
\begin{itemize}
\item \textit{Last Time Slots of a Day} Students should not be scheduled to attend an event in the last
time slot of a day (that is, time slots 9, 18, 27, 36, or 45).
\item \textit{More than Two in a Row} Students should not have to attend three (or more) events in
consecutive time slots occurring in the same day.
\item \textit{One Class on a Day} Students should not be required to attend only one event in a particular day.
\end{itemize}

On a final note, a solution with events left unassigned is a valid solution as sometimes the hard constraints are too strong for the whole set of events to schedule.




\subsection{Evaluation}

To evaluate a solution, the same model from the 2007 ITC \cite{itc:sol} was followed so we could, in a later stage, compare our results with those obtained in that competition.

We start by calculating the \textit{Distance to Feasibility} which is the sum of all students that are required to attend events that were left unassigned. Then a penalty for each soft constraint violated is added.

The number of soft constraint violations is calculated as follows:
\begin{itemize}
\item Count the number of occurrences of a student having just one class on a day (e.g. count
2 if a student has two days with only one class).
\item Count the number of occurrences of a student having more than two classes
consecutively (3 consecutively scores 1, 4 consecutively scores 2, 5 consecutively scores
3, etc). Classes at the end of the day followed by classes at the beginning of the next
day do not count as consecutive.
\item Count the number of occurrences of a student having a class in the last timeslot of the
day.
\end{itemize}

Sum the three counts to give the soft constraints score. 
The goal is to first minimize the \textit{Distance to Feasibility}, and only then the soft constraints, seeing that a solution with 0 \textit{Distance to Feasibility} would be possible to implement in a real world situation whereas a solution with a low soft constraint score but with \textit{Distance to Feasibility} greater than 0 would not. This evaluation can be expressed as:
$$
Distance\,to\,Feasibility = \sum_{i=1}^n e_i*se_i $$ where $$
 e_i = \left\{
     \begin{array}{ll}
       1  : & Event\, i\, is\, unassigned \\
       0  : & otherwise
     \end{array}
   \right.
$$ and $ se_i $ is the number of students attending event $i$.
  
  
  




\section{Algorithms}


\subsection{Iterative Construction and Simulated Annealing}

\subsubsection{Iterative Construction}

It starts with all events being unassigned. During each iteration, an unassigned
event is chosen, all available time slots and rooms are tested and the number of constraint violations is kept for each assignment, so the assignment that has the least number of violations is chosen. If this number is not 0 (i. e.if this causes any violations of hard constraints with existing assignments) the conflicting variables are unassigned. For example, if there is another class at the selected time that has the same student, that class will be unassigned.

The only hard constraint that is ignored during this phase is the room constraint. It is allowed to assign an event to a time slot, even though it has no room available. The reasoning behind this decision is simple. Given the hard constrains, the real difficulty is to find an available time slot. After this has been found, it is easier to rearrange to room assignments inside that slot. The construction ends after a fixed number of iterations, or when all the events have been assigned to a time slot.

As for event selection there are two possible ways, \textit{random} or \textit{most restricted}. If \textit{most restricted} is chosen the events are ordered by descending  number of attending students , then by ascending number of available slots and finally by descending number of required features, and the first of the list is always chosen. This means that events that are harder to assign, or are likely to create more conflicts, are assigned sooner. If \textit{random} is chosen, a random event is chosen in each iteration.
\newpage
\textbf{Pseudo code}
\begin{algorithmic}[1]
\State $S \leftarrow  emptySolution();UA \leftarrow  allEvents;$
\While {stopping criteria is not reached}
	\State $e \leftarrow removeEvent(UA);$
	\State $slots \leftarrow  getAvailableSlots(e);$
	\State $min \gets +\infty;$
	\ForAll{$ slot \in slots$}
		\State $ conflicts \leftarrow getConflictingEvents(e,i);$
		\If{$conflicts.size() < min$}
			\State $min \leftarrow conflicts.size();$
			\State $minConflicts \gets conflicts$
		\ElsIf{$conflicts.size() = min \wedge random()\ge 0.5$}
			\State $min \leftarrow conflicts.size()$
			\State $minConflicts \gets conflicts;$
		\EndIf
	\EndFor
	\State $a \gets S[min];$
	\State $r \gets getAvailableRoom(a,e);$
	\State $assignEvent(a,e,slot,r);$
	\ForAll{$ event \in minConflicts$}
		\State $ unassignEvent(a,event);$
	\EndFor
\EndWhile
\State \Return $S$	


\end{algorithmic}




\subsubsection{Simulated Annealing}

After finding an initial solution with the iterative construction, this solution is then improved with the simulated annealing algorithm. 

In each iteration of this algorithm a new assignment is generated based on the current assignment and is graded following the rules previously explained. In order to emphasize the \textit{Distance to Feasibility}, it is given a greater weight on the overall value of the solution. If this new solution is better than the current one, this solution is accepted. If not, this solution can still be accepted, with probability $$ p_{accept} = e^{-\frac{\Delta}{T}} $$ where $\Delta$ is the difference between the new solution's value and the current one. Then the current solution is compared with the best solution found up until this moment, and if it better we update the best solution to the current solution. If not, this iteration is considered a \textbf{stable iteration}.

After a fixed number \textit{coolRate} of iterations, the temperature \textbf{T} is cooled down (multiplied by) the constant \textit{coolFactor}, making it more unlikely to accept worse solutions as more time passes. Though one modification was made in this regard. If the number of \textbf{stable iterations} passes the \textit{reheat} constant, the temperature is increased (multiplied by $\frac{1}{coolRate}$, trying to avoid a local minima.

For example, suppose out current best solution is valued with 10.For every iteration where this does not change (we do not find a better solution), the number of stable iterations increases, with the temperature still diminishing, making it harder to leave the current solution. So after \textit{reheat} stable iterations we start increasing the temperature, instead of diminishing it, making it easier to accept a worse solution. Now one of two things can happen: either the maximum number of stable iterations is reached, and the algorithm stops, and the best solution (10) is returned, or we find a new best solution (<10) after accepting a series of worse solutions, thus having avoided the local minima, and the number of stable iterations is back to 0, and the temperature starts diminishing again (from it's current value).

The algorithm stops after a fixed number of \textbf{stable iterations} or when the value is lower than a predefined minimum.

As for finding new solutions, the following \textit{neighbours} were implemented, and are chosen with equal probability. Only solutions that don't violate any hard constraint are considered.
\begin{itemize}
\item Time Move - An event and a new time slot are selected randomly . If it is possible to reassign
the event into the new time slot while keeping its room without any conflict, such an assignment
is returned. The following time slots are tried otherwise, with the first available time
slot being returned if any are available. All time slots are tested.
\item Room Move - An event and a new room are selected randomly. If it is possible to reassign the
event into the new room while keeping its current time assignment without any conflict, such
an assignment is returned. The following rooms are tried otherwise, with the first available
room being returned if any are available.
\item Event Move - An event is randomly selected. A new time slot and a room are randomly selected.
If there is no conflict in assigning the selected event into the new time and room, such
an assignment is returned. If there is exactly one event conflicting with the new assignment
and it is possible to swap these events, this swap is returned. Otherwise, it tries to use one
of the following time slots and rooms (first it keeps the selected time slot and picks another
room, then the same with the following time slot, etc.).
\item Event Swap - Two events are randomly selected. If it is possible to swap these two events,
such a swap is returned. Otherwise it tries to swap the times but pick a different room for
these events (in a similar way as Room Move).
\end{itemize}

One more thing to note is that, in order to give priority to minimizing the \textit{Distance to Feasibility}, the random event selector is skewed towards the unassigned events, increasing the probability of these events being chosen by a predetermined factor.
\newpage
\textbf{Pseudo code}
\begin{algorithmic}[1]
\Require IA the Initial Assignment
\State $currentState \leftarrow  IA;$
\State $currentEnergy \leftarrow  evaluate(currentState);$
\State $bestEnergy \gets currentEnergy;$
\State $bestState \gets currentState$
\State $stableIt \gets 0; i \gets 0;$
\While {stopping criteria is not reached}
	\State $T \leftarrow getTemperature(i,stableIt);$
	\State $newState \leftarrow  getNewState(currentState);$
	\State $newEnergy \gets evaluate(newState);$
	\State $\Delta E \gets newEnergy - currentEnergy;$
	\State $acceptProb \gets getAcceptanceProbability(\Delta E,T);$
	\If{$acceptProb \geq random()$}
			\State $currentEnergy  \gets newEnergy;$
			\State $currentState \gets newState$
	\EndIf
	\If{$currentEnergy <  bestEnergy $}
			\State $ bestEnergy \gets currentEnergy ;$
			\State $ bestState\gets currentState$
			\State $stableIt \gets 0;$
	\Else
		\State $stableIt \gets stableIt +1;$
	\EndIf
	\State $i \gets i +1;$
\EndWhile
\State \Return $bestState$	
	


\end{algorithmic}


\subsection{Hill Climbing and Genetic Algorithm}
(To Do)



\subsubsection{Purpose}
(Incomplete)

In this approach, Hill Climbing will be used to generate the initial population for the genetic algorithm.
It will use the same neighbouring functions as Simulated Annealing, starting from an empty solution. It was chosen this way in order to save time, thus allowing more time for the genetic algorithm to run while giving it a better base to start on, rather than having a random population.

\subsubsection{Representation}


\subsubsection{Implementation}


\newpage
\textbf{Pseudo code}
\begin{algorithmic}[1]
\Require IP the Initial Population
\State $currentPopulation \leftarrow  IP;$
\State $bestValue \gets +\infty;$
\State $stableIt \gets 0; i \gets 0;$
\While {stopping criteria is not reached}
	\State $chosenToReproduce \leftarrow getChosenToReproduce(currentPopulation);$
	\State $children \leftarrow  getChildren(chosenToReproduce);$
	\State $mutate(children);$
	\State $currentPopulation \gets selectMostFit(currentPopulation,children);$
\EndWhile
\State \Return $currentPopulation$	
	


\end{algorithmic}


\section{Results}

The tables below contain the results of running the algorithms on 24 different instances. 100 runs were made for each instance and the best are shown in the table below. In the appendix we can find the 10 best solutions found for each instance.

\medskip% adds some space before the table

\begin{tabular}{l  *{12}{c}}
Instance Number & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\
\toprule
Distance to Feasibility & 256 & 253 & 0 & 0 & 0 & 0 & 0 & 0 & 412 & 716 & 0 & 0 \\
More than two in a row & 80 & 93 & 33 & 14 & 86 & 78 & 23 & 40 & 76 & 70 & 23 & 8 \\
One class on a day  & 11 & 115 & 28 & 34 & 114 & 93 & 18 & 50 & 112 & 93 & 44 & 51 \\
Last time slot of a day & 1001 & 1128 & 1026 & 1040 & 576 & 547 & 615 & 565 & 1243 & 1154 & 646 & 1231 \\
\bottomrule
Overall Value & 1448 & 1589 & 1087 & 1088 & 776 & 718 & 656 & 655 & 1843 & 2033 & 713 & 1290 \\


\end{tabular}

\medskip% adds some space after the table
\medskip% adds some space before the table

\begin{tabular}{l  *{12}{c}}
Instance Number & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 & 21 & 22 & 23 & 24 \\
\toprule
Distance to Feasibility & 0 & 0 & 0 & 0 & 0 & 0 & 457 & 0 & 0 & 538 & 102 & 118 \\
More than two in a row & 74 & 79 & 26 & 30 & 82 & 83 & 18 & 26 & 76 & 61 & 80 & 23 \\
One class on a day  & 103 & 102 & 43 & 54 & 109 & 104 & 30 & 41 & 96 & 91 & 105 & 35 \\
Last time slot of a day & 581 & 659 & 531 & 582 & 476 & 853 & 1418 & 1404 & 620 & 1073 & 2250 & 1226 \\
\bottomrule
Overall Value & 758 & 840 & 600 & 666 & 667 & 1040 & 1923 & 1471 & 792 & 1763 & 2537 & 1402 \\


\end{tabular}

\medskip% adds some space after the table

\section{Conclusions}

To do

\begin{thebibliography}{9}

\bibitem{itc:2007}
2007 International Time Tabling Competition:
\url{http://www.cs.qub.ac.uk/itc2007/postenrolcourse/course_post_index.htm}
\bibitem{itc:sol}
2007 International Time Tabling Competition - Solution Evaluation:
\url{http://www.cs.qub.ac.uk/itc2007/postenrolcourse/course_post_index_files/evaluation.htm}


\end{thebibliography}

\end{document}

